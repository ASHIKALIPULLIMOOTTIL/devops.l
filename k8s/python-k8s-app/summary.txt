âœ… COMPLETE FLOW: Python App â†’ Docker â†’ Kubernetes (Minikube)
ğŸ”¹ STEP 1: Start Kubernetes Cluster (Minikube)
Command
minikube start --driver=docker

Usage

Creates a local Kubernetes cluster

Uses Docker as the VM/driver

Starts:

API server

Scheduler

Controller manager

etcd

Verify
kubectl get nodes


âœ… Confirms cluster is running

ğŸ”¹ STEP 2: Use Minikubeâ€™s Docker Daemon
Command
eval $(minikube docker-env)

Usage (VERY IMPORTANT)

Makes your terminal use Minikubeâ€™s Docker engine

Images you build are:

Stored inside Minikube

Immediately usable by Kubernetes

Avoids ImagePullBackOff

ğŸ”‘ Without this â†’ Kubernetes cannot see your image

ğŸ”¹ STEP 3: Create Python Application
Files created
app.py
requirements.txt
Dockerfile

Purpose

app.py â†’ Flask app

requirements.txt â†’ Python dependencies

Dockerfile â†’ Build container image

ğŸ”¹ STEP 4: Build Docker Image
Command
docker build -t python-k8s-app:1.0 .

Usage

Builds a Docker image

Tags it as python-k8s-app:1.0

Stored inside Minikube Docker

Verify (optional)
docker images

ğŸ”¹ STEP 5: Create Deployment (deployment.yml)
Command
kubectl apply -f deployment.yml

Usage

Creates a Deployment

Deployment creates:

ReplicaSet

3 Pods (as you defined)

Verify
kubectl get deployment
kubectl get pods


âœ” Self-healing
âœ” Replica management
âœ” Scaling enabled

ğŸ”¹ STEP 6: Create Service (service.yml)
Command
kubectl apply -f service.yml

Usage

Exposes pods to the outside

Provides:

Stable IP

Load balancing

Type used: NodePort

Verify
kubectl get service

ğŸ”¹ STEP 7: Access Application (Correct Way)
Command
minikube service python-app-service

Usage

Automatically:

Finds Minikube IP

Finds NodePort

Opens browser

OR manually:

minikube ip

http://<MINIKUBE-IP>:<NODE-PORT>

ğŸ”¹ STEP 8: Verify Load Balancing (Optional)
Command
kubectl get pods -o wide


Then repeatedly refresh browser
â†’ Traffic is distributed across 3 pods

ğŸ”¹ STEP 9: Access Pod Internally (Debugging only)
Command
minikube ssh
curl <POD-IP>:5000

Usage

Works only inside cluster

Pod IPs are not public

âŒ Never use Pod IPs in production

ğŸ”¹ STEP 10: Cleanup Old Resources
Command
kubectl delete deployment nginx-deployment

Usage

Removes unused deployment

Frees cluster resources

******************************************************

A Kubernetes Service provides a stable IP and DNS name for a set of Pods and performs load balancing to distribute traffic among them.

ğŸ” How Service Load Balancing works (with your 3 pods)

You currently have:

kubectl get pods

python-app-deployment-... (3 pods)


When you hit:

http://192.168.49.2:30007


Kubernetes:

Picks one of the 3 pods

Sends traffic to it

Rotates requests across pods

ğŸ’¡ This is built-in load balancing (round-robin style)

âŒ Why you should NOT use Pod IPs

Example Pod IP:

10.244.0.15


Problems:

Pod can die anytime

IP will change

No load balancing

ğŸ‘‰ Services solve this problem

*******************************************

5ï¸âƒ£ PORT(S) â†’ 5000:30007/TCP

This is the most important part ğŸ‘‡

<service-port> : <node-port>

Breakdown:

5000 â†’ Container port (Flask app listens here)

30007 â†’ NodePort (opened on Minikube VM)

So traffic flow is:

Browser
 â†’ 192.168.49.2:30007
 â†’ Service
 â†’ Pod:5000
 
 **************************************************
 ğŸ§­ What is Ingress (in one line)

Ingress provides HTTP/HTTPS routing (domain/path based) to Services using a single external entry point.

Instead of:

IP:30007


You get:

http://python.local/

ğŸ— Current setup (you already have)
Browser
 â†’ NodePort Service
 â†’ Python Pods (3)


Weâ€™ll convert it to:

Browser
 â†’ Ingress Controller
 â†’ Service
 â†’ Python Pods

ğŸ”¹ STEP 1: Enable Ingress Controller in Minikube

Minikube does NOT have Ingress by default.

Command
minikube addons enable ingress

What it does

Installs NGINX Ingress Controller

Creates:

ingress-nginx namespace

ingress controller pod

Verify
kubectl get pods -n ingress-nginx


You should see:

ingress-nginx-controller-xxxxx   Running

ğŸ”¹ STEP 2: Your Service must be ClusterIP (IMPORTANT)

Ingress talks to Services, not Pods.

Edit service.yml
apiVersion: v1
kind: Service
metadata:
  name: python-app-service
spec:
  type: ClusterIP
  selector:
    app: python-app
  ports:
    - port: 5000
      targetPort: 5000


Apply:

kubectl apply -f service.yml


Verify:

kubectl get svc


You should now see:

python-app-service   ClusterIP

ğŸ”¹ STEP 3: Create Ingress Resource

Create file:

gedit ingress.yml

ingress.yml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: python-app-ingress
spec:
  rules:
  - host: python.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: python-app-service
            port:
              number: 5000


Apply:

kubectl apply -f ingress.yml


Verify:

kubectl get ingress

ğŸ”¹ STEP 4: Map Domain to Minikube IP

Get Minikube IP:

minikube ip


Example:

192.168.49.2


Edit /etc/hosts:

sudo nano /etc/hosts


Add:

192.168.49.2  python.local


Save & exit.

ğŸ”¹ STEP 5: Access Your App ğŸ‰

Open browser:

http://python.local


âœ… Ingress routes request
âœ… Service load-balances
âœ… 3 pods handle traffic

ğŸ”„ Verify traffic flow (important)
kubectl describe ingress python-app-ingress

kubectl get pods -o wide


Refresh browser â†’ traffic rotates across pods.


$$$*****************************************************************
What Ingress actually does in your app

You already have 3 running pods:

python-app-deployment
 â”œâ”€â”€ Pod A (10.244.0.17)
 â”œâ”€â”€ Pod B (10.244.0.18)
 â””â”€â”€ Pod C (10.244.0.20)


These pods are NOT directly accessible from outside.

ğŸ”¹ Without Ingress (what you had earlier)

You used a NodePort Service:

http://192.168.49.2:30007

Flow:
Browser
 â†’ Minikube IP:30007
 â†’ Service
 â†’ Pod

Problems:

âŒ Port number required
âŒ One service = one port
âŒ No domain names
âŒ No path routing
âŒ Not production friendly

ğŸ”¹ What Ingress adds (THIS is the key)

Ingress acts as a smart HTTP/HTTPS gateway.

New flow (your current setup):
Browser
 â†’ http://python.local
 â†’ Ingress (NGINX)
 â†’ Service (python-app-service)
 â†’ One of the Pods


Ingress sits in front of all services.

ğŸ”¹ What Ingress is ACTUALLY doing for you
1ï¸âƒ£ Acts like a reverse proxy

Ingress receives all incoming HTTP requests.

Example:

GET / HTTP/1.1
Host: python.local


NGINX Ingress reads:

Host name

Path

Then decides:
â¡ where to send the request

2ï¸âƒ£ Routes traffic using rules (your ingress.yml)

Your rule:

Host: python.local
Path: /
Backend: python-app-service:5000


Meaning:

Any request coming to python.local/ â†’ send to python-app-service

3ï¸âƒ£ Load balances automatically

Ingress does NOT talk to pods directly.

It talks to the Service, which then load-balances:

Request 1 â†’ Pod A
Request 2 â†’ Pod B
Request 3 â†’ Pod C


You saw this here:

(10.244.0.17, 10.244.0.18, 10.244.0.20)

4ï¸âƒ£ Gives you domain names (VERY important)

Instead of:

http://192.168.49.2:30007


You now use:

http://python.local


This is how real production apps work.

5ï¸âƒ£ One entry point for MANY apps

Ingress allows this:

/            â†’ python-app
/api         â†’ backend-app
/admin       â†’ admin-app


Or:

python.local â†’ python-app
api.local    â†’ api-service


ğŸ”¥ One IP, many services.

************************************************

ğŸ” Add TLS to your Python app (Minikube)
STEP 1ï¸âƒ£ Create TLS certificate (on Ubuntu host)

Run this in your project directory:

openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout python.local.key \
  -out python.local.crt \
  -subj "/CN=python.local"

What this does

python.local.key â†’ private key

python.local.crt â†’ certificate

Valid for 1 year

Domain name = python.local

Verify:

ls


You should see:

python.local.key
python.local.crt

STEP 2ï¸âƒ£ Create Kubernetes TLS Secret
kubectl create secret tls python-app-tls \
  --cert=python.local.crt \
  --key=python.local.key


Check:

kubectl get secrets


You should see:

python-app-tls


ğŸ“Œ Ingress will use this secret for HTTPS

STEP 3ï¸âƒ£ Edit Ingress to enable TLS

Open your ingress file:

gedit ingress.yml

âœ… Correct Ingress with TLS
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: python-app-ingress
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - python.local
    secretName: python-app-tls
  rules:
  - host: python.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: python-app-service
            port:
              number: 5000


Save & close.

Apply it:

kubectl apply -f ingress.yml

STEP 4ï¸âƒ£ Map domain to Minikube IP (IMPORTANT)

Get Minikube IP:

minikube ip


Example:

192.168.49.2


Edit hosts file:

sudo gedit /etc/hosts


Add this line:

192.168.49.2   python.local


Save.

STEP 5ï¸âƒ£ Test HTTPS ğŸš€

Open browser and go to:

https://python.local


ğŸ§  Key takeaways (very important)
Component	Role
TLS cert	Enables HTTPS
Secret	Stores cert securely
Ingress	Terminates TLS
Service	Load balances pods
Pods	Run your app


